#!/usr/bin/env tsx

/**
 * Enhanced Product Sync Script with Real-Time Progress Tracking
 * 
 * This script synchronizes products from Printful to our local database with
 * comprehensive progress tracking and real-time status updates.
 * 
 * Features:
 * - Real-time progress tracking with detailed status updates
 * - Estimated time remaining calculations
 * - Comprehensive error handling and warning collection
 * - Modular design for maintainability
 * - Database-driven product enhancements preservation
 * - Enhanced logging with visual progress indicators
 * 
 * @author Generated by AI Assistant
 * @version 2.0.0
 * @created 2024-12-19
 */

import 'dotenv/config';
import { printful } from '../src/lib/printful-client';
import { productService } from '../src/lib/database/services/product-service';
import { SyncProgressTracker, ProgressUtils } from '../src/lib/sync-progress';
import type { PrintfulProduct, PrintfulVariant } from '../src/types';
import type { SyncLog } from '../src/lib/database/schema';

interface SyncStats {
  productsProcessed: number;
  productsCreated: number;
  productsUpdated: number;
  productsDeleted: number;
  variantsProcessed: number;
  variantsCreated: number;
  variantsUpdated: number;
  variantsDeleted: number;
  errors: string[];
}

/**
 * Enhanced ProductSync class with real-time progress tracking
 */
class ProductSync {
  private stats: SyncStats = {
    productsProcessed: 0,
    productsCreated: 0,
    productsUpdated: 0,
    productsDeleted: 0,
    variantsProcessed: 0,
    variantsCreated: 0,
    variantsUpdated: 0,
    variantsDeleted: 0,
    errors: [],
  };

  private progressTracker: SyncProgressTracker | null = null;
  private syncLog: SyncLog | null = null;

  /**
   * Main sync function
   */
  async syncProducts(): Promise<void> {
    this.logWithIcon('üöÄ', 'Starting enhanced product sync...');
    const startTime = Date.now();

    // Create sync log entry with enhanced progress tracking
    this.syncLog = await productService.createSyncLog({
      operation: 'full_sync',
      status: 'queued',
      currentStep: 'Initializing sync process',
      progress: 0,
    });

    this.progressTracker = new SyncProgressTracker(this.syncLog.id);

    try {
      // Phase 1: Fetch products from Printful
      await this.updateProgress({
        status: 'fetching_products',
        currentStep: 'Fetching products from Printful API...',
        progress: 5,
      });

      const printfulProducts = await this.fetchAllProducts();
      this.logWithIcon('üì¶', `Found ${printfulProducts.length} products with variants from Printful`);

      // Phase 2: Initialize progress tracker
      const initUpdate = this.progressTracker!.initialize(printfulProducts.length);
      await this.updateProgress(initUpdate);

      // Phase 3: Analyze existing products
      await this.updateProgress({
        currentStep: 'Analyzing existing products...',
        progress: 16,
      });

      // Get ALL products (not just active) to properly detect deletions
      const existingProducts = await productService.getAllProductsForAdmin();
      const existingProductIds = new Set(existingProducts.map(p => p.printfulId));
      const incomingProductIds = new Set(printfulProducts.map(p => p.id));
      const productsToDelete = existingProducts.filter(p => !incomingProductIds.has(p.printfulId));

      // Debug logging for product deletion
      this.logWithIcon('üîç', `Found ${existingProducts.length} existing products in database`);
      this.logWithIcon('üîç', `Found ${printfulProducts.length} products from Printful`);
      this.logWithIcon('üîç', `Products to delete: ${productsToDelete.length}`);
      
      if (productsToDelete.length > 0) {
        this.logWithIcon('üóëÔ∏è', `Products marked for deletion:`);
        productsToDelete.forEach(product => {
          this.logWithIcon('üóëÔ∏è', `  - ${product.name} (Printful ID: ${product.printfulId})`);
        });
      }

      // Phase 4: Delete obsolete products
      if (productsToDelete.length > 0) {
        await this.updateProgress({
          currentStep: `Removing ${productsToDelete.length} obsolete products...`,
          progress: 18,
        });

        await this.deleteObsoleteProducts(productsToDelete);
      }

      // Phase 5: Process products with progress tracking
      await this.updateProgress({
        status: 'processing_products',
        currentStep: `Processing ${printfulProducts.length} products...`,
        progress: 20,
      });

      await this.processProductsWithProgress(printfulProducts);

      // Phase 6: Finalize sync
      await this.finalizeSyncWithSuccess(startTime);

    } catch (error) {
      this.logWithIcon('üí•', `Sync failed: ${error}`);
      await this.finalizeSyncWithError(error, startTime);
      
      // Re-throw for script execution context
      if (process.env.NODE_ENV !== 'production') {
        throw error;
      }
    }
  }

  /**
   * Process products with detailed progress updates
   */
  private async processProductsWithProgress(printfulProducts: PrintfulProduct[]): Promise<void> {
    for (let i = 0; i < printfulProducts.length; i++) {
      const product = printfulProducts[i];
      
      try {
        // Update progress for current product
        const startUpdate = this.progressTracker!.startProduct(i, product.name);
        await this.updateProgress(startUpdate);

        // Process the product
        const processingResult = await this.processProductWithTracking(product);
        
        // Update statistics
        const completeUpdate = this.progressTracker!.completeProduct(processingResult);
        await this.updateProgress(completeUpdate);

        this.stats.productsProcessed++;
        this.logWithIcon('‚úÖ', `Processed: ${product.name} (${i + 1}/${printfulProducts.length})`);

      } catch (error) {
        const errorMsg = `Failed to process product ${product.name}: ${error}`;
        this.stats.errors.push(errorMsg);
        this.progressTracker!.addWarning(errorMsg);
        this.logWithIcon('‚ùå', errorMsg);
      }
    }
  }

  /**
   * Delete obsolete products with progress tracking
   */
  private async deleteObsoleteProducts(productsToDelete: any[]): Promise<void> {
    for (const product of productsToDelete) {
      try {
        await productService.deleteProduct(product.id);
        this.stats.productsDeleted++;
        this.logWithIcon('üóëÔ∏è', `Deleted: ${product.name} (${product.printfulId})`);
      } catch (error) {
        const errorMsg = `Failed to delete product ${product.name}: ${error}`;
        this.stats.errors.push(errorMsg);
        this.progressTracker!.addWarning(errorMsg);
        this.logWithIcon('‚ùå', errorMsg);
      }
    }
  }

  /**
   * Finalize sync with success status
   */
  private async finalizeSyncWithSuccess(startTime: number): Promise<void> {
    const duration = Date.now() - startTime;
    const status = this.stats.errors.length > 0 ? 'partial' : 'success';
    
    const finalUpdate = this.progressTracker!.complete(
      status,
      this.stats.errors.length > 0 ? this.stats.errors.join('; ') : undefined
    );

    await this.updateProgress({
      ...finalUpdate,
      productsProcessed: this.stats.productsProcessed,
      productsCreated: this.stats.productsCreated,
      productsUpdated: this.stats.productsUpdated,
      productsDeleted: this.stats.productsDeleted,
      variantsProcessed: this.stats.variantsProcessed,
      variantsCreated: this.stats.variantsCreated,
      variantsUpdated: this.stats.variantsUpdated,
      variantsDeleted: this.stats.variantsDeleted,
    });

    this.printSummary(duration);
  }

  /**
   * Finalize sync with error status
   */
  private async finalizeSyncWithError(error: unknown, startTime: number): Promise<void> {
    const duration = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);

    if (this.syncLog && this.progressTracker) {
      const errorUpdate = this.progressTracker.complete('error', errorMessage);
      await this.updateProgress(errorUpdate);
    } else if (this.syncLog) {
      // Fallback if progressTracker wasn't initialized
      await productService.updateSyncLog(this.syncLog.id, {
        status: 'error',
        currentStep: 'Sync failed with error',
        errorMessage,
        duration,
      });
    }
  }

  /**
   * Update progress in database
   */
  private async updateProgress(update: any): Promise<void> {
    if (!this.syncLog) return;

    try {
      await productService.updateSyncProgress({
        syncLogId: this.syncLog.id,
        ...update,
      });
    } catch (error) {
      console.error('Failed to update sync progress:', error);
    }
  }

  /**
   * Enhanced logging with icons
   */
  private logWithIcon(icon: string, message: string): void {
    console.log(`${icon} ${message}`);
  }

  /**
   * Fetch all products from Printful with their variants
   */
  private async fetchAllProducts(): Promise<PrintfulProduct[]> {
    try {
      console.log('Fetching products from Printful store...');
      const response = await printful.get('store/products');
      const basicProducts = response.result as Array<{
        id: string;
        external_id: string;
        name: string;
        thumbnail_url: string;
        is_ignored: boolean;
      }>;
      console.log(`Found ${basicProducts.length} products in store`);

      // Now fetch each product with its variants
      const productsWithVariants: PrintfulProduct[] = [];
      
      for (let i = 0; i < basicProducts.length; i++) {
        const basicProduct = basicProducts[i];
        
        // Update progress during variant fetching
        const fetchProgress = 5 + Math.round((i / basicProducts.length) * 10); // Progress 5-15%
        await this.updateProgress({
          status: 'fetching_products',
          currentStep: `Fetching variants for product ${i + 1}/${basicProducts.length}: ${basicProduct.name}`,
          progress: fetchProgress,
        });
        
        try {
          console.log(`üîç Fetching variants for product ${i + 1}/${basicProducts.length}: ${basicProduct.name}`);
          const productResponse = await printful.get(`store/products/${basicProduct.id}`);
          const fullProduct = productResponse.result as {
            sync_product: {
              id: string;
              external_id: string;
              name: string;
              thumbnail_url: string;
              is_ignored: boolean;
            };
            sync_variants: Array<{
              id: number;
              external_id: string;
              name: string;
              retail_price: string;
              currency: string;
              files: Array<{
                id: number;
                type: string;
                url: string;
                preview_url: string;
              }>;
              options: Array<{
                id: string;
                value: string;
              }>;
              size: string | null;
              color: string | null;
              is_enabled: boolean;
              in_stock: boolean;
              is_ignored: boolean;
            }>;
          };

          // Convert to our expected format
          const printfulProduct: PrintfulProduct = {
            id: fullProduct.sync_product.id,
            external_id: fullProduct.sync_product.external_id,
            name: fullProduct.sync_product.name,
            thumbnail_url: fullProduct.sync_product.thumbnail_url,
            is_ignored: fullProduct.sync_product.is_ignored,
            variants: fullProduct.sync_variants || []
          };

          productsWithVariants.push(printfulProduct);
          console.log(`‚úÖ Fetched ${fullProduct.sync_variants?.length || 0} variants for ${basicProduct.name}`);
          
          // Small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (error) {
          console.error(`‚ùå Failed to fetch variants for product ${basicProduct.name}:`, error);
          // Add product without variants as fallback
          productsWithVariants.push({
            id: basicProduct.id,
            external_id: basicProduct.external_id,
            name: basicProduct.name,
            thumbnail_url: basicProduct.thumbnail_url,
            is_ignored: basicProduct.is_ignored,
            variants: []
          });
        }
      }

      console.log(`üì¶ Successfully fetched ${productsWithVariants.length} products with variants`);
      return productsWithVariants;
      
    } catch (error) {
      console.error(`‚ùå Failed to fetch products:`, error);
      throw error;
    }
  }

  /**
   * Process a single product with tracking statistics
   */
  private async processProductWithTracking(printfulProduct: PrintfulProduct): Promise<{
    created?: boolean;
    updated?: boolean;
    variantsCreated?: number;
    variantsUpdated?: number;
  }> {
    // Check if product exists in database
    const existingProduct = await productService.getProductByPrintfulId(printfulProduct.id);
    const isNewProduct = !existingProduct;

    // Upsert product
    const product = await productService.upsertProduct(printfulProduct);
    
    const result = {
      created: isNewProduct,
      updated: !isNewProduct,
      variantsCreated: 0,
      variantsUpdated: 0,
    };
    
    if (isNewProduct) {
      this.stats.productsCreated++;
    } else {
      this.stats.productsUpdated++;
    }

    // Process variants
    if (printfulProduct.variants && printfulProduct.variants.length > 0) {
      const existingVariants = existingProduct?.variants || [];
      const variantResults = await productService.upsertVariants(product.id, printfulProduct.variants);
      
      // Calculate variant statistics
      result.variantsCreated = variantResults.filter(v => 
        !existingVariants.find(ev => ev.printfulId === v.printfulId)
      ).length;
      result.variantsUpdated = variantResults.length - result.variantsCreated;
      
      this.stats.variantsCreated += result.variantsCreated;
      this.stats.variantsUpdated += result.variantsUpdated;
      this.stats.variantsProcessed += variantResults.length;
    }

    // Auto-categorize and tag if it's a new product
    if (isNewProduct) {
      try {
        await productService.autoCategorizeAndTagProduct(product);
      } catch (error) {
        const warningMsg = `Failed to auto-categorize product ${product.name}: ${error}`;
        this.progressTracker?.addWarning(warningMsg);
        console.warn(`‚ö†Ô∏è ${warningMsg}`);
      }
    }

    return result;
  }

  /**
   * Process a single product (legacy method for backward compatibility)
   */
  private async processProduct(printfulProduct: PrintfulProduct): Promise<void> {
    console.log(`Processing: ${printfulProduct.name} (${printfulProduct.id})`);
    await this.processProductWithTracking(printfulProduct);
  }

  /**
   * Process variants for a product
   */
  private async processVariants(productId: string, printfulVariants: PrintfulVariant[] | undefined): Promise<void> {
    if (!printfulVariants || !Array.isArray(printfulVariants)) {
              console.log(`  No variants found for product ${productId}`);
      return;
    }

          console.log(`  Processing ${printfulVariants.length} variants...`);

    // Get existing variants to track changes
    const existingVariants = await productService.getProductById(productId);
    const existingVariantCount = existingVariants?.variants.length || 0;

    // Upsert variants
    const upsertedVariants = await productService.upsertVariants(productId, printfulVariants);
    
    this.stats.variantsProcessed += printfulVariants.length;
    
    // Calculate variant changes (this is a simplified approach)
    if (existingVariantCount < upsertedVariants.length) {
      this.stats.variantsCreated += upsertedVariants.length - existingVariantCount;
    } else if (existingVariantCount > upsertedVariants.length) {
      this.stats.variantsDeleted += existingVariantCount - upsertedVariants.length;
    } else {
      this.stats.variantsUpdated += upsertedVariants.length;
    }

          console.log(`  Processed ${upsertedVariants.length} variants`);
  }

  /**
   * Print sync summary
   */
  private printSummary(duration: number): void {
    console.log('\nSync Summary:');
    console.log('================');
    console.log(`Duration: ${duration}ms`);
    console.log(`Products processed: ${this.stats.productsProcessed}`);
    console.log(`Products created: ${this.stats.productsCreated}`);
    console.log(`Products updated: ${this.stats.productsUpdated}`);
    console.log(`Products deleted: ${this.stats.productsDeleted}`);
    console.log(`Variants processed: ${this.stats.variantsProcessed}`);
    console.log(`Variants created: ${this.stats.variantsCreated}`);
    console.log(`Variants updated: ${this.stats.variantsUpdated}`);
    console.log(`Variants deleted: ${this.stats.variantsDeleted}`);

    if (this.stats.errors.length > 0) {
      console.log(`Errors: ${this.stats.errors.length}`);
      this.stats.errors.forEach(error => console.log(`  - ${error}`));
    } else {
      console.log('Sync completed successfully!');
    }
  }
}

// Run the sync
async function main() {
  try {
    const sync = new ProductSync();
    await sync.syncProducts();
  } catch (error) {
    console.error('üí• Sync failed:', error);
    process.exit(1);
  }
}

// Export the ProductSync class for use in other modules
export { ProductSync };

// Only run if this file is executed directly
if (require.main === module) {
  main();
}
