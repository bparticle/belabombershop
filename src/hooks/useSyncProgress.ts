/**
 * Sync Progress Hook
 * 
 * Custom React hook for managing real-time sync progress tracking.
 * Provides automatic polling, state management, and lifecycle handling
 * for sync operations.
 * 
 * Features:
 * - Automatic polling with configurable intervals
 * - Optimized polling that increases frequency during active syncs
 * - Error handling and retry logic
 * - Memory leak prevention with cleanup
 * - Type-safe state management
 * 
 * @author Generated by AI Assistant
 * @version 1.0.0
 * @created 2024-12-19
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import type { SyncLog } from '../lib/database/schema';
import { getAdminToken } from '../lib/auth';

interface SyncProgressState {
  activeSyncLog: SyncLog | null;
  recentSyncLogs: SyncLog[];
  isLoading: boolean;
  error: string | null;
  lastUpdated: Date | null;
}

interface SyncProgressOptions {
  /**
   * Polling interval in milliseconds for active syncs
   * @default 2000 (2 seconds)
   */
  activePollInterval?: number;
  
  /**
   * Polling interval in milliseconds for inactive periods
   * @default 10000 (10 seconds)
   */
  inactivePollInterval?: number;
  
  /**
   * Maximum number of recent sync logs to fetch
   * @default 5
   */
  maxRecentLogs?: number;
  
  /**
   * Whether to start polling immediately
   * @default false
   */
  autoStart?: boolean;
}

interface SyncProgressActions {
  /**
   * Trigger a new sync operation
   */
  triggerSync: () => Promise<{ syncLogId?: string; error?: string }>;
  
  /**
   * Cancel an active sync operation
   */
  cancelSync: (syncLogId: string) => Promise<{ success: boolean; error?: string }>;
  
  /**
   * Manually refresh sync data
   */
  refresh: () => Promise<void>;
  
  /**
   * Start polling for updates
   */
  startPolling: () => void;
  
  /**
   * Stop polling for updates
   */
  stopPolling: () => void;
}

type UseSyncProgressReturn = SyncProgressState & SyncProgressActions;

/**
 * Hook for managing sync progress state and operations
 */
export const useSyncProgress = (options: SyncProgressOptions = {}): UseSyncProgressReturn => {
  const {
    activePollInterval = 2000,
    inactivePollInterval = 10000,
    maxRecentLogs = 5,
    autoStart = false,
  } = options;

  const [state, setState] = useState<SyncProgressState>({
    activeSyncLog: null,
    recentSyncLogs: [],
    isLoading: false,
    error: null,
    lastUpdated: null,
  });

  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const isPollingRef = useRef(false);

  /**
   * Check if there's an active sync operation
   */
  const hasActiveSync = useCallback((): boolean => {
    return state.activeSyncLog !== null && 
           ['queued', 'fetching_products', 'processing_products', 'finalizing'].includes(state.activeSyncLog.status);
  }, [state.activeSyncLog]);

  /**
   * Fetch sync data from the API
   */
  const fetchSyncData = useCallback(async (): Promise<void> => {
    const token = getAdminToken();
    if (!token) {
      setState(prev => ({ ...prev, error: 'Authentication required' }));
      return;
    }

    try {
      const [syncLogsResponse, activeSyncsResponse] = await Promise.all([
        fetch(`/api/admin/sync?limit=${maxRecentLogs}`, {
          headers: { 'Authorization': `Bearer ${token}` },
        }),
        fetch('/api/admin/sync?active=true', {
          headers: { 'Authorization': `Bearer ${token}` },
        }),
      ]);

      if (!syncLogsResponse.ok || !activeSyncsResponse.ok) {
        throw new Error('Failed to fetch sync data');
      }

      const [syncLogsData, activeSyncsData] = await Promise.all([
        syncLogsResponse.json(),
        activeSyncsResponse.json(),
      ]);

      // Debug logging for progress tracking
      const activeSync = activeSyncsData.activeSyncs?.[0] || null;
      if (activeSync) {
        console.log(`ðŸ”„ Active sync found: ${activeSync.id} (${activeSync.status}) - Progress: ${activeSync.progress}%`);
        console.log(`ðŸ“Š Step: ${activeSync.currentStep}`);
      }

      setState(prev => ({
        ...prev,
        recentSyncLogs: syncLogsData.syncLogs || [],
        activeSyncLog: activeSync,
        error: null,
        lastUpdated: new Date(),
      }));

    } catch (error) {
      console.error('Failed to fetch sync data:', error);
      setState(prev => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Unknown error',
      }));
    }
  }, [maxRecentLogs]);

  /**
   * Start polling with dynamic intervals
   */
  const startPolling = useCallback((): void => {
    if (isPollingRef.current) return;

    isPollingRef.current = true;

    const poll = () => {
      if (!isPollingRef.current) return;

      fetchSyncData().finally(() => {
        if (isPollingRef.current) {
          const interval = hasActiveSync() ? activePollInterval : inactivePollInterval;
          pollingIntervalRef.current = setTimeout(poll, interval);
        }
      });
    };

    // Start immediately
    poll();
  }, [fetchSyncData, hasActiveSync, activePollInterval, inactivePollInterval]);

  /**
   * Stop polling
   */
  const stopPolling = useCallback((): void => {
    isPollingRef.current = false;
    if (pollingIntervalRef.current) {
      clearTimeout(pollingIntervalRef.current);
      pollingIntervalRef.current = null;
    }
  }, []);

  /**
   * Trigger a new sync operation
   */
  const triggerSync = useCallback(async (): Promise<{ syncLogId?: string; error?: string }> => {
    const token = getAdminToken();
    if (!token) {
      return { error: 'Authentication required' };
    }

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const response = await fetch('/api/admin/sync', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to trigger sync');
      }

      const data = await response.json();
      
      // Immediately refresh to get the new sync log
      await fetchSyncData();
      
      return { syncLogId: data.syncLogId };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      setState(prev => ({ ...prev, error: errorMessage }));
      return { error: errorMessage };
    } finally {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, [fetchSyncData]);

  /**
   * Cancel an active sync operation
   */
  const cancelSync = useCallback(async (syncLogId: string): Promise<{ success: boolean; error?: string }> => {
    const token = getAdminToken();
    if (!token) {
      return { success: false, error: 'Authentication required' };
    }

    try {
      const response = await fetch(`/api/admin/sync/${syncLogId}/cancel`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to cancel sync');
      }

      // Refresh data to reflect the cancellation
      await fetchSyncData();
      
      return { success: true };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return { success: false, error: errorMessage };
    }
  }, [fetchSyncData]);

  /**
   * Manual refresh
   */
  const refresh = useCallback(async (): Promise<void> => {
    setState(prev => ({ ...prev, isLoading: true }));
    try {
      await fetchSyncData();
    } finally {
      setState(prev => ({ ...prev, isLoading: false }));
    }
  }, [fetchSyncData]);

  /**
   * Initialize polling on mount
   */
  useEffect(() => {
    if (autoStart) {
      startPolling();
    }

    return () => {
      stopPolling();
    };
  }, [autoStart, startPolling, stopPolling]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      stopPolling();
    };
  }, [stopPolling]);

  return {
    ...state,
    triggerSync,
    cancelSync,
    refresh,
    startPolling,
    stopPolling,
  };
};

export default useSyncProgress;
